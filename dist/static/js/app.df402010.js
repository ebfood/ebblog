(function(n){function t(t){for(var a,s,r=t[0],c=t[1],l=t[2],p=0,u=[];p<r.length;p++)s=r[p],Object.prototype.hasOwnProperty.call(i,s)&&i[s]&&u.push(i[s][0]),i[s]=0;for(a in c)Object.prototype.hasOwnProperty.call(c,a)&&(n[a]=c[a]);d&&d(t);while(u.length)u.shift()();return o.push.apply(o,l||[]),e()}function e(){for(var n,t=0;t<o.length;t++){for(var e=o[t],a=!0,r=1;r<e.length;r++){var c=e[r];0!==i[c]&&(a=!1)}a&&(o.splice(t--,1),n=s(s.s=e[0]))}return n}var a={},i={app:0},o=[];function s(t){if(a[t])return a[t].exports;var e=a[t]={i:t,l:!1,exports:{}};return n[t].call(e.exports,e,e.exports,s),e.l=!0,e.exports}s.m=n,s.c=a,s.d=function(n,t,e){s.o(n,t)||Object.defineProperty(n,t,{enumerable:!0,get:e})},s.r=function(n){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},s.t=function(n,t){if(1&t&&(n=s(n)),8&t)return n;if(4&t&&"object"===typeof n&&n&&n.__esModule)return n;var e=Object.create(null);if(s.r(e),Object.defineProperty(e,"default",{enumerable:!0,value:n}),2&t&&"string"!=typeof n)for(var a in n)s.d(e,a,function(t){return n[t]}.bind(null,a));return e},s.n=function(n){var t=n&&n.__esModule?function(){return n["default"]}:function(){return n};return s.d(t,"a",t),t},s.o=function(n,t){return Object.prototype.hasOwnProperty.call(n,t)},s.p="";var r=window["webpackJsonp"]=window["webpackJsonp"]||[],c=r.push.bind(r);r.push=t,r=r.slice();for(var l=0;l<r.length;l++)t(r[l]);var d=c;o.push([0,"chunk-vendors"]),e()})({0:function(n,t,e){n.exports=e("56d7")},"0123":function(n,t,e){"use strict";e("18d9")},"041c":function(n,t,e){},"0e29":function(n,t,e){},"18d9":function(n,t,e){},"1a06":function(n,t,e){},"1a3f":function(n,t,e){"use strict";e("99db")},"22a2":function(n,t,e){"use strict";e("7e4b")},"245a":function(n,t,e){"use strict";e.r(t);e("4d63"),e("ac1f"),e("25f0"),e("b0c0"),e("caad"),e("2532");var a=e("96eb"),i=e.n(a),o=e("ee80"),s=o.mdList;i.a.mock("/api/index","get",o),i.a.mock(RegExp("api/detail.*"),"get",(function(n){for(var t=JSON.parse(n.body).id,e=0;e<s.length;e++)if(t===s[e].id)return{article:{title:s[e].title,date:s[e].date,content:s[e].content,cover:s[e].cover}}})),i.a.mock(RegExp("api/category.*"),"get",(function(n){for(var t=JSON.parse(n.body).name,e=[],a=0;a<s.length;a++)t===s[a].category&&e.push(s[a]);return e})),i.a.mock(RegExp("api/tag.*"),"get",(function(n){for(var t=JSON.parse(n.body).name,e=[],a=0;a<s.length;a++)s[a].tag.includes(t)&&e.push(s[a]);return e}))},3209:function(n,t,e){"use strict";e("d732")},3215:function(n,t,e){},"34dd":function(n,t,e){"use strict";e("0e29")},"407d":function(n,t,e){"use strict";e("4605")},4605:function(n,t,e){},4637:function(n,t,e){n.exports=e.p+"static/img/avatar.0e18181a.jpeg"},"4e75":function(n,t,e){},5101:function(n,t,e){},"56d7":function(n,t,e){"use strict";e.r(t);e("e260"),e("e6cf"),e("cca6"),e("a79d"),e("159b");var a,i,o=e("2b0e"),s=function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("div",{attrs:{id:"app"}},[e("router-view")],1)},r=[],c=(e("5c0b"),e("2877")),l={},d=Object(c["a"])(l,s,r,!1,null,null,null),p=d.exports,u=e("8c4f"),g=function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("div",{staticClass:"home"},[e("header-nav"),e("div",{staticClass:"container"},[e("left"),e("main-part",n._l(this.blogList,(function(n){return e("blog-box",{key:n.id,attrs:{data:n}})})),1),e("right",{attrs:{tags:n.tagList,tops:n.topList}})],1),e("footer-nav")],1)},m=[],h=function(){var n=this,t=n.$createElement;n._self._c;return n._m(0)},f=[function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("div",{staticClass:"header"},[e("div",{staticClass:"nav"},[e("span",{staticClass:"banner"},[e("a",{staticClass:"iconfont",attrs:{href:"/"}},[n._v("")]),e("span",[n._v("EB BLOG")])]),e("span",{staticClass:"about"},[e("a",{staticClass:"iconfont",attrs:{href:"https://github.com/ebfood"}},[n._v("")]),e("a",{staticClass:"iconfont",attrs:{href:"/wechat.jpg"}},[n._v("")])])])])}],b={name:"Header"},v=b,x=(e("e1b1"),Object(c["a"])(v,h,f,!1,null,"97ea104a",null)),y=x.exports,w=function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("div",{staticClass:"left"},[e("profile"),e("sort")],1)},_=[],k=function(){var n=this,t=n.$createElement;n._self._c;return n._m(0)},j=[function(){var n=this,t=n.$createElement,a=n._self._c||t;return a("div",{staticClass:"profile"},[a("img",{staticClass:"avatar",attrs:{src:e("4637"),alt:"avatar"}}),a("div",{staticClass:"content"},[a("h4",[n._v("ebfood")])])])}],S={name:"Profile"},C=S,E=(e("6a64"),Object(c["a"])(C,k,j,!1,null,"70a203c9",null)),O=E.exports,L=function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("div",{staticClass:"sort"},[e("h4",[n._v("文章分类")]),e("ul",[e("li",[e("router-link",{attrs:{to:"/"}},[e("span",{staticClass:"iconfont"},[n._v("")]),n._v("全部 ")])],1),e("li",[e("router-link",{attrs:{to:"/category/前端"}},[e("span",{staticClass:"iconfont"},[n._v("")]),n._v("前端 ")])],1),e("li",[e("router-link",{attrs:{to:"/category/算法题"}},[e("span",{staticClass:"iconfont"},[n._v("")]),n._v("算法题 ")])],1),e("li",[e("router-link",{attrs:{to:"/category/葱妹自救指南"}},[e("span",{staticClass:"iconfont"},[n._v("")]),n._v("葱妹自救指南 ")])],1)])])},D=[],M={name:"sort"},P=M,I=(e("af62"),Object(c["a"])(P,L,D,!1,null,"161e6ae2",null)),$=I.exports,F={name:"Left",components:{Profile:O,Sort:$}},A=F,T=(e("f56b"),Object(c["a"])(A,w,_,!1,null,"5994fc48",null)),B=T.exports,N=function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("div",{staticClass:"main-part"},[n._t("default")],2)},H=[],z={name:"MainPart",props:{blogs:Array}},J=z,X=(e("407d"),Object(c["a"])(J,N,H,!1,null,"b18704fe",null)),R=X.exports,q=function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("div",{staticClass:"right"},[e("top-blog",{attrs:{data:n.tops}}),e("tag-box",{attrs:{data:n.tags}}),e("Doing")],1)},Q=[],G=function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("div",{staticClass:"tag-box"},[e("h4",[n._v("热门标签")]),e("ul",n._l(this.data,(function(t,a){return e("li",{key:a},[e("router-link",{staticClass:"tags",attrs:{to:"/tag/"+t.name}},[n._v(" #"+n._s(t.name)+" ")])],1)})),0)])},V=[],W={name:"Tag",props:{data:Array}},K=W,U=(e("22a2"),Object(c["a"])(K,G,V,!1,null,"54b13258",null)),Y=U.exports,Z=function(){var n=this,t=n.$createElement;n._self._c;return n._m(0)},nn=[function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("div",{staticClass:"doing"},[e("h4",[n._v("DOING")]),e("ul",[e("li",[n._v("沉迷前端，死磕基础，毕设拖延症，算法题拖延症，租房准备中。")])])])}],tn={name:"doing"},en=tn,an=(e("1a3f"),Object(c["a"])(en,Z,nn,!1,null,"14bff220",null)),on=an.exports,sn=function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("div",{staticClass:"top-blog"},[e("h4",[n._v("置顶文章")]),e("ul",n._l(n.data,(function(t){return e("li",{key:t.id},[e("router-link",{staticClass:"tags",attrs:{to:"/detail/"+t.id}},[n._v(" "+n._s(t.title)+" ")])],1)})),0)])},rn=[],cn={name:"top-blog",props:{data:Array}},ln=cn,dn=(e("0123"),Object(c["a"])(ln,sn,rn,!1,null,"c58ff74a",null)),pn=dn.exports,un={name:"Right",components:{TagBox:Y,Doing:on,TopBlog:pn},props:{tags:Array,tops:Array}},gn=un,mn=(e("57ae"),Object(c["a"])(gn,q,Q,!1,null,"4a70d26a",null)),hn=mn.exports,fn=function(){var n=this,t=n.$createElement;n._self._c;return n._m(0)},bn=[function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("div",{staticClass:"footer"},[e("p",[n._v("Copyright © 2021 EB BLOG")])])}],vn={name:"Footer"},xn=vn,yn=(e("3209"),Object(c["a"])(xn,fn,bn,!1,null,"5d55191b",null)),wn=yn.exports,_n=function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("div",{staticClass:"blog-box",on:{click:function(t){return n.handleClick(n.data.id)}}},[e("div",{staticClass:"cover",style:{"background-image":"url("+n.data.cover+")"}}),e("div",{staticClass:"content"},[e("h2",[n._v(n._s(n.data.title))]),e("p",[n._v(n._s(n.data.description))]),e("span",[n._v(n._s(n.data.date))])])])},kn=[],jn={name:"blog-box",props:{data:Object},methods:{handleClick:function(n){this.$router.push("/detail/".concat(n))}}},Sn=jn,Cn=(e("34dd"),Object(c["a"])(Sn,_n,kn,!1,null,"71f0bb20",null)),En=Cn.exports,On=e("b85c"),Ln=(e("a4d3"),e("e01a"),e("bc3a")),Dn=e.n(Ln),Mn={methods:{getCpnData:function(n){Dn.a.get("/api/index").then((function(t){var e,a=t.data.mdList,i={},o=Object(On["a"])(a);try{for(o.s();!(e=o.n()).done;){var s,r=e.value,c=Object(On["a"])(r.tag);try{for(c.s();!(s=c.n()).done;){var l=s.value;l in i?i[l].push(r.id):i[l]=[r.id]}}catch(p){c.e(p)}finally{c.f()}r.category in n.category?n.category[r.category].push(r.id):n.category[r.category]=[r.id],r.top&&n.topList.push({id:r.id,title:r.title}),n.blogList.push({id:r.id,date:r.date,cover:r.cover,title:r.title,description:r.description})}}catch(p){o.e(p)}finally{o.f()}for(var d in i)n.tagList.push({name:d,amount:i[d]});n.tagList.sort((function(n,t){return t.amount.length-n.amount.length}))}))}}},Pn=Mn,In=Object(c["a"])(Pn,a,i,!1,null,null,null),$n=In.exports,Fn={name:"Home",components:{HeaderNav:y,Left:B,Right:hn,MainPart:R,FooterNav:wn,BlogBox:En},data:function(){return{tagList:[],category:{},topList:[],blogList:[]}},mounted:function(){$n.methods.getCpnData(this)}},An=Fn,Tn=(e("d623"),Object(c["a"])(An,g,m,!1,null,"e114c27e",null)),Bn=Tn.exports,Nn=function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("div",{staticClass:"detail"},[e("header-nav"),e("div",{staticClass:"container"},[e("left"),e("main-part",[e("div",{staticClass:"markdown-body"},[e("vue-markdown",{directives:[{name:"highlight",rawName:"v-highlight"}],attrs:{source:this.article.article.content}})],1)]),e("right",{attrs:{tags:n.tagList,tops:n.topList}})],1),e("footer-nav")],1)},Hn=[],zn=e("9ce6"),Jn=e.n(zn),Xn={name:"Detail",components:{HeaderNav:y,Left:B,Right:hn,MainPart:R,FooterNav:wn,VueMarkdown:Jn.a},data:function(){return{tagList:[],category:{},topList:[],blogList:[],articleID:"",article:{article:{content:""}}}},methods:{getArticleID:function(){this.articleID=this.$route.params.id},getDetail:function(){var n=this;Dn()({method:"get",url:"/api/detail",data:{id:this.articleID}}).then((function(t){n.article=t.data}))}},beforeMount:function(){$n.methods.getCpnData(this),this.getArticleID(),this.getDetail()},watch:{$route:function(){this.getArticleID(),this.getDetail()}}},Rn=Xn,qn=(e("d429"),Object(c["a"])(Rn,Nn,Hn,!1,null,"d89c82ba",null)),Qn=qn.exports,Gn=function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("div",{staticClass:"tag"},[e("header-nav"),e("div",{staticClass:"container"},[e("left"),e("main-part",n._l(this.article,(function(n){return e("blog-box",{key:n.id,attrs:{data:n}})})),1),e("right",{attrs:{tags:n.tagList,tops:n.topList}})],1),e("footer-nav")],1)},Vn=[],Wn=(e("b0c0"),{name:"Tag",components:{HeaderNav:y,Left:B,Right:hn,MainPart:R,FooterNav:wn,BlogBox:En},data:function(){return{tagList:[],category:{},topList:[],blogList:[],articleID:"",article:{}}},methods:{getArticleID:function(){this.articleID=this.$route.params.name},getDetail:function(){var n=this;Dn()({method:"get",url:"/api/tag",data:{name:this.articleID}}).then((function(t){n.article=t.data}))}},beforeMount:function(){$n.methods.getCpnData(this),this.getArticleID(),this.getDetail()},watch:{$route:function(){this.getArticleID(),this.getDetail()}}}),Kn=Wn,Un=(e("7142"),Object(c["a"])(Kn,Gn,Vn,!1,null,"723e309e",null)),Yn=Un.exports,Zn=function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("div",{staticClass:"category"},[e("header-nav"),e("div",{staticClass:"container"},[e("left"),e("main-part",n._l(this.article,(function(n){return e("blog-box",{key:n.id,attrs:{data:n}})})),1),e("right",{attrs:{tags:n.tagList,tops:n.topList}})],1),e("footer-nav")],1)},nt=[],tt={name:"Category",components:{HeaderNav:y,Left:B,Right:hn,MainPart:R,FooterNav:wn,BlogBox:En},data:function(){return{tagList:[],category:{},topList:[],blogList:[],articleID:"",article:{}}},methods:{getArticleID:function(){this.articleID=this.$route.params.name},getDetail:function(){var n=this;Dn()({method:"get",url:"/api/category",data:{name:this.articleID}}).then((function(t){n.article=t.data}))}},beforeMount:function(){$n.methods.getCpnData(this),this.getArticleID(),this.getDetail()},watch:{$route:function(){this.getArticleID(),this.getDetail()}}},et=tt,at=(e("841a"),Object(c["a"])(et,Zn,nt,!1,null,"734bc34e",null)),it=at.exports;o["a"].use(u["a"]);var ot=[{path:"/",name:"Home",component:Bn},{path:"/detail/:id",name:"Detail",component:Qn},{path:"/category/:name",name:"Category",component:it},{path:"/tag/:name",name:"Tag",component:Yn}],st=new u["a"]({routes:ot}),rt=st,ct=(e("d238"),e("f8d3"),e("3215"),e("1487")),lt=e.n(ct);e("9f21");e("245a"),o["a"].directive("highlight",(function(n){var t=n.querySelectorAll("pre code");t.forEach((function(n){lt.a.highlightBlock(n)}))})),o["a"].config.productionTip=!1,new o["a"]({router:rt,render:function(n){return n(p)}}).$mount("#app")},"57ae":function(n,t,e){"use strict";e("e1b9")},"5c0b":function(n,t,e){"use strict";e("9c0c")},"5e19":function(n,t,e){},"6a64":function(n,t,e){"use strict";e("5e19")},7142:function(n,t,e){"use strict";e("041c")},"7e4b":function(n,t,e){},"841a":function(n,t,e){"use strict";e("1a06")},"8cba":function(n,t,e){},"99db":function(n,t,e){},"9c0c":function(n,t,e){},abbb:function(n,t,e){},af62:function(n,t,e){"use strict";e("abbb")},d238:function(n,t,e){},d429:function(n,t,e){"use strict";e("dea6")},d623:function(n,t,e){"use strict";e("4e75")},d732:function(n,t,e){},dea6:function(n,t,e){},e1b1:function(n,t,e){"use strict";e("8cba")},e1b9:function(n,t,e){},ee80:function(n){n.exports=JSON.parse('{"mdList":[{"id":"0001","date":"2021-3-15","category":"前端","tag":["vue","响应式布局","CSS"],"top":true,"title":"EBBLOG开发笔记","description":"记录本博客的开发过程，技术点，踩过的坑。","cover":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fstatic001.infoq.cn%2Fresource%2Fimage%2Fc4%2F01%2Fc4251ee38c2039602d69cac1d3ab9d01.jpg&refer=http%3A%2F%2Fstatic001.infoq.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1618367358&t=ac837c3418183f9aa030b9c7cf7e7fb3","content":"# 技术分析\\n\\n+ vue\\n+ 响应式布局\\n\\n\\n\\n# 响应式布局\\n\\n思路：用container容器装下面紫色绿色蓝色，用@media媒体查询屏幕宽度，分成三个区间\\n```scss\\n@media screen and (min-width: 320px) and (max-width: 749px) {\\n  @import \\"~@/assets/CSS/mobile.scss\\";\\n}\\n@media screen and (min-width: 750px) and (max-width: 1279px) {\\n  @import \\"~@/assets/CSS/middle.scss\\";\\n}\\n```\\n两个scss中，分别重写部分样式，把这些放在Home.vue的style的最下方，就可以覆盖组件里面的默认配置，目的就达成了！\\n\\n默认的配置第一区间，container默认的css\\n![image-20210313170654253](https://ebcode.oss-cn-shanghai.aliyuncs.com/img/image-20210313170654253.png)\\n\\n\\n\\n第二区间，调用middle.scss，适用于手机横屏，iPad\\n\\n![image-20210313185012723](https://ebcode.oss-cn-shanghai.aliyuncs.com/img/image-20210313185012723.png)\\n\\n第三区间，侧边栏都跑到下面去，适用于手机。\\n\\n![image-20210313185119165](https://ebcode.oss-cn-shanghai.aliyuncs.com/img/image-20210313185119165.png)\\n\\n\\n"},{"id":"0002","date":"2021-3-26","category":"前端","tag":["前端知识框架"],"top":true,"title":"前端基础知识框架梳理！","description":"这是我自己整理的前端基础知识体系，包括HTML/CSS，JS的基础、闭包、原型、异步、WebAPI，HTTP协议相关知识体系。具体内容不是以详细为目标，而旨在帮自己构建一个完整的前端知识框架，先把框架打好，以便可以在任何一个点深入。","cover":"https://twenty-tech.com/wp-content/uploads/2018/12/Front-end-developemtn-1.png","content":" \\n\\n# HTML/CSS\\n\\n## HTML\\n\\n### 如何理解HTML语义化\\n\\n+ 让人更容易读懂, 增加可读性\\n+ 搜索引擎优化\\n\\n### 块状元素 内联元素\\n\\ninline: span img input button\\n\\n\\n\\n## 盒模型\\n\\n### 盒子模型宽度的计算\\n\\n+ offsetWidth=(内容宽度+内边距+边框) 无外边距\\n+ border-box 向内缩\\n\\n### margin纵向层叠\\n\\n+ 相邻元素margin top bottom 重叠\\n+ 空白的p也有类似的效果, margin会重叠\\n\\n### margin负数\\n\\n+ margin-top/left 负数, 会拽着往前\\n+ margin-right 负数, 右侧元素左移, 本身不受影响\\n+ margin-bottom负数, 本身不变, 下方元素上移(侵入)\\n\\n\\n\\n## BFC\\n\\n### 是什么\\n\\n块级格式化上下文, 一块独立的渲染区域,内部元素渲染不会影响边界以外的元素.\\n\\n### 形成条件\\n\\n+ float不是none\\n+ positon absolute or fixed\\n+ overflow 不是 visible\\n+ display是 flex或者inline-block\\n\\n### BFC的作用\\n\\n+ 利用BFC避免margin重叠。\\n+ 自适应两栏布局\\n+ 清除浮动\\n\\n\\n\\n## float\\n\\n### 圣杯布局和双飞翼布局\\n\\n实现一个**两侧宽度固定，中间宽度自适应的三栏布局**。\\n\\n+ 使用float\\n+ 中间栏width100%, 两侧用margin负值, 向中间内容横向重叠\\n+ 防止中间内容被覆盖, \\n  圣杯在大容器给一个padding, 然后吧两个侧栏的position relative, 移走 \\n  双飞翼用margin, 侧栏只提供margin的负值就位, 中间栏给个margin.\\n\\n### 手写clearfix\\n\\n基本知识点：\\n\\n1. div的高度由div内部的内容高度决定\\n2. float浮动后div脱离文档流\\n\\n所以：当一个div内部嵌套的div浮动后，外部的div高度会塌陷。\\n解决方案, 给容器添加一个伪类, 让他来感知浮动元素, 清除浮动, 这样就会撑开容器.\\n\\n```CSS\\n.clearfix:after{\\n\\tcontent: \'\';\\n\\tdisplay: block;\\n\\tclear: both;\\n}\\n```\\n\\n\\n\\n## flex\\n\\n### 三点骰子问题\\n\\n+ 主轴 justify-content: space-between;\\n+ 点点设置 align-self: center | flex-end;\\n\\n\\n\\n## position\\n\\n### absolute和relative分别依据什么定位?\\n\\n+ relative依据自身定位\\n+ absolute依据最近一层的定位元素(absolute relative fixed body) 来定位\\n\\n### 居中对齐的实现方式\\n\\n+ 水平居中\\n  + inline: text-align\\n  + block: margin 0 auto;\\n  + absolute left:50% margin-left: -half;\\n+ 垂直居中\\n  + inline: line-height\\n  + absolute: \\n    1. top 50%  margin-top\\n    2. top:50% left: 50% + transform: translate(-50%, -50%) 这个是CSS3\\n    3. top left bottom right=0 + margin: auto\\n\\n\\n\\n## css图文样式\\n\\n### line-height如何继承\\n\\n+ 如果带单位, 继承就是具体数值\\n+ 如果是倍数, 那就继承下来倍数, 子元素自己的font-size乘倍数就是行高\\n+ (坑)如果是带%, 就会在父亲里面直接计算好具体数字, 再继承给子元素\\n\\n\\n\\n## 响应式\\n\\n### rem是什么\\n\\n+ px绝对长度单位\\n+ em, 相对长度单位,相对于父亲\\n+ rem, 相对的, 相对于根元素的长度\\n  给html设置font_size, rem就的值就是font_size的倍数,  rem = 实际px / basefont\\n\\n### 响应式的方案?\\n\\n+ media-query, 根据不同屏幕设置根元素font-size\\n+ 长度全部都用rem\\n\\n### vw/vh\\n\\n+ vh网页视口高度的 1/100\\n  window.innerHeight = 100vh\\n+ vw视口宽度的1/100\\n\\n\\n\\n# Javascript基础语法\\n\\n## 变量类型与计算\\n\\n### 值类型和引用类型\\n\\n 引用类型：对象，数组， null，函数 \\n\\n### typeof运算符\\n\\n+ 识别所有值类型\\n+ 识别函数\\n+ 识别是否是引用类型(都显示object)\\n\\n### 深拷贝\\n\\n```javascript\\nfunction deepClone(obj = {}) {\\n  // 不是引用类型就直接返回, 注意null坑\\n  if (typeof obj !== \'object\' || obj == null) {\\n    return obj\\n  }\\n\\n  //是数组还是对象呢？\\n  let result\\n  obj instanceof Array ? result = [] : result = {}\\n  \\n  // 遍历，递归\\n  for (let key in obj) {\\n    if (obj.hasOwnProperty(key)) {\\n      result[key] = deepClone(obj[key])\\n    }\\n  }\\n\\n  return result\\n}\\n```\\n\\n### 类型转换的坑\\n\\n+ 字符串+数字 = 字符串\\n+ 字符串+ true = 字符串\\n+ 100 == \'100\'  // true\\n+ 0 == \'\',  0 == false, false == \'\', null == undefined ,  双等号尽量会转换\\n+ 用双等号只有一个情形，== null <=> ===null || === undefined, 其余一律三等\\n\\n### if语句与逻辑运算\\n\\ntruly变量： !!a === true\\nfalsely变量：!!a === false\\n`0, NaN, \'\', null, undefined, false` , 是falsely变量， 其余都是truly\\n\\n|| 返回第一个真值，&&返回第一个假值\\n\\n```JavaScript\\nresult = value1 || value2 || value3;  //寻找第一个真\\nresult = value1 && value2 && value3; //寻找第一个假\\n```\\n\\n\\n\\n## 原型和原型链\\n\\n### 原型\\n\\n+ 每个函数（class）都有显示原型prototype属性，值是个普通对象\\n+ 每个实例都有隐式原型` __proto__`属性，值是个普通对象\\n+ 实例的`__proto__` 指向它构造函数（class）的prototype属性\\n\\n原型的执行规则式：\\n\\n+ 现在自身的属性和方法寻找\\n+ 如果找不到就到 `__proto__` 里面去找\\n\\n### 原型链\\n\\n当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的`__proto__`隐式原型上查找，即它的构造函数的`prototype`，如果还没有找到就会再在构造函数的`prototype`的`__proto__`中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。\\n\\n![这里写图片描述](https://img-blog.csdn.net/20180620134143385?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9lcm1pbmdu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\\n\\n图文引用https://blog.csdn.net/xiaoermingn/article/details/80745117\\n\\n第二个例图：\\n\\n![image-20210323233108518](https://ebcode.oss-cn-shanghai.aliyuncs.com/img/image-20210323233108518.png)\\n\\n### 类型判断\\n\\ninstanceof 判断 变量属于哪个class，是顺着原型链向上找，找那个类的prototype\\n\\n### 题目\\n\\n#### 手写一个简单jQuery，考虑插件和扩展性？\\n\\n```JavaScript\\nclass jQuery {\\n  // 构造器\\n  constructor(selector) {\\n    const result = document.querySelectorAll(selector)\\n    const length = result.length\\n    //构建array like\\n    for (let i = 0; i < length; i++) {\\n      this[i] = result[i]\\n    }\\n    this.length = length\\n    this.selector = selector\\n  }\\n\\n  get(index) {\\n    return this[index]\\n  }\\n\\n  each(fn) {\\n    for (let i = 0; i < this.length; i++) {\\n      const elem = this[i]\\n      fn(elem)\\n    }\\n  }\\n\\n  // 事件绑定\\n  on(type, fn) {\\n    return this.each(elem => {\\n      elem.addEventListener(type, fn, false)\\n    })\\n  }\\n}\\n\\n// 使用\\nlet $p = new jQuery(\'p\')\\nconsole.log($p)\\nconsole.log($p.get(1))\\n$p.each(elem => console.log(elem.nodeName)) // p p p\\n$p.on(\'click\',()=>alert(\'clicked\'))\\n\\n// 考虑插件\\njQuery.prototype.dialog = function(info){\\n  console.log(info)\\n}\\n\\n//定义新的对象并继承自jquery实现jquery 的扩展性，也就是造轮子\\nclass MyjQ extends jQuery {\\n  constructor(selector) {\\n    super(selector) //用于调用父对象上的函数\\n  }\\n\\n  addFunc() {\\n    console.log(\'new func\')\\n  }\\n}\\n\\nm = new MyjQ(\'p\')\\nm.dialog(1)\\nm.addFunc()\\n```\\n\\n\\n\\n## 作用域和闭包\\n\\n### 作用域和自由变量\\n\\n+ 全局作用域，函数作用域，块级作用域。\\n+ 自由变量：当前作用域没有定义但是被使用了**的变量**，向上作用域一层一层依次寻找，直到被找到了，如果全局都没找到，就报错了。\\n\\n### 闭包\\n\\n+ 函数作为参数被传递\\n+ 函数作为返回值被返回\\n\\n所有的自由变量会在函数定义的作用域依次向上寻找，不是在执行的地方\\n\\n### this\\n\\n来看阮一峰的博客：http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html\\n\\nthis的取值在函数执行的时候确认的，不是函数定义的时候确认的\\n\\n+ 作为普通函数：window\\n+ call apply bind：参数1\\n+ 对象方法：当前对象，也就是点符号前面那个对象\\n+ class方法中：当前创建的实例\\n+ 箭头函数：本身没有this\\n\\n### 题目\\n\\n#### 手写bind函数？\\n\\n```JavaScript\\nfunction func(...arg){\\n  console.log(this)\\n  console.log(arg)\\n}\\n\\nFunction.prototype.myBind = function (thisArg,...arg) {\\n  let self = this // 谁调用了mybind，this就是谁，这里就是func了\\n  console.log(self)\\n  return function (...arg2) {\\n    self.apply(thisArg, [...arg, ...arg2])\\n  }\\n}\\n\\nfunc(1,2,2,3,4)\\nlet f2 = func.myBind({a: 1},2, 3, 4)\\nf2(6,6,6)\\n```\\n\\n\\n\\n#### 闭包场景举例？\\n\\n+ 隐藏数据, 只提供api\\n\\n  ```javascript\\n  function createCache() {\\n    let data = {}\\n    // 闭包\\n    return {\\n      set: function (key, value) {\\n        this.data[key] = value\\n      },\\n      get: function (key) {\\n        return this.data[key]\\n      }\\n    }\\n  }\\n  ```\\n\\n  \\n\\n## 异步\\n\\n### 单线程和异步\\n\\n+ js是单线程语言\\n+ JS和DOM渲染共用一个线程\\n+ 遇到等待，网络请求，定时请求，同步会阻塞代码执行，异步不会阻塞代码执行。\\n\\n### 应用场景\\n\\n+ 网络请求：ajax，图片加载\\n+ 定时任务：setTimeOut\\n\\n### Promise\\n\\n<img src=\\"https://ebcode.oss-cn-shanghai.aliyuncs.com/img/image-20210324191450642.png\\" alt=\\"image-20210324191450642\\" style=\\"zoom: 33%;\\" />\\n\\n+ 利用回调函数层层嵌套的代码格式，显然显得冗余又容易出错，这就被称为 “回调地狱” 或者“回调深渊”。\\n+ Promise，可以理解为一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。构造函数接收两个参数，resolve和reject，这两个参数都是函数，是引擎提供的。\\n\\n#### 三种状态\\n\\n+ pending：过程中\\n+ resolved：解决了\\n+ rejected：失败了\\n\\n#### 状态的表现和变化\\n\\n+ 状态的变化只能是pending->resolved  /  pending->rejected\\n+ 变化是不可逆的\\n+ pending状态，不会触发then和catch\\n+ fulfilled状态，会触发后续的then回调函数\\n+ rejected状态，会触发后续的catch回调函数\\n+ ps：很多教程里把resolved(已完成)等价于fullfilled(成功)状态,也有的Promise状态定型为resolved包含fullfilled和rejected两种状态。但是由于习惯写法，Promise中“成功”的回调函数的名字依然叫做resolve。\\n\\n#### then和catch对状态的影响\\n\\n+ then正常返回fulfilled状态的Promise，里面报错就返回rejected\\n+ catch正常也返回fulfilled，里面报错返回rejected\\n\\n### event-loop\\n\\nJS是单线程的，异步要基于回调来实现，even-loop就是异步回调的实现原理\\n\\n![image-20210324225519899](https://ebcode.oss-cn-shanghai.aliyuncs.com/img/image-20210324225519899.png)\\n\\n+ 同步代码一行行的放在Call Stack中执行\\n+ 遇到异步，会先记录下来，等待时机（定时，网络请求）\\n+ 时机到了，就移动到Callback Queue\\n+ 如果Call Stack为空（同步代码执行完成）event-loop立即开始工作\\n+ event-loop轮询查找Callback Queue，如果里面有东西就将其移动到Call Stack中执行\\n+ event-loop接着继续查找Callback Queue\\n\\n#### DOM事件和event loop\\n\\n+ 异步（setTimeout，ajax等）使用回调，基于event loop\\n+ DOM事件也使用回调，基于event loop\\n\\n\\n\\n### async/await\\n\\n用同步的语法编写，彻底消灭回调函数\\n\\n+ 执行async返回的是Promise对象\\n+ await相当于Promise.then\\n+ try catch用来捕获异常，替代了Promise.catch\\n+ await后面都是异步，在同步的代码执行完成了之后才会执行\\n\\n### 微任务/宏任务\\n\\n#### 定义\\n\\n+ 宏任务：setTimeout， setInterval，ajax，DOM事件\\n+ 微任务：Promise async/await\\n+ 微任务执行的时机早于宏任务\\n  + 宏任务是在DOM渲染后触发\\n  + 微任务是DOM渲染前触发\\n  + 微任务是ES6语法规定的，宏任务是浏览器规定的，微任务其实有自己单独的队列![image-20210325134720596](https://ebcode.oss-cn-shanghai.aliyuncs.com/img/image-20210325134720596.png)\\n\\n#### event loop 和dom渲染\\n\\n+ 每次Call Stack清空（同步任务执行完成）都是Dom重新渲染的机会\\n+ DOM如果改变了此时会重新渲染\\n+ 然后再去触发Event loop\\n\\n### 题目\\n\\n#### promise实现图片加载\\n\\n```javascript\\nconst url1 = \'https://aecpm.alicdn.com/simba/img/TB1JNHwKFXXXXafXVXXSutbFXXX.jpg\',\\nurl2 = \'https://aecpm.alicdn.com/simba/img/TB1j4LLKpXXXXcbaXXXSutbFXXX.jpg\'\\n\\nfunction loadImage(src) {\\n  return new Promise((resolve, reject) => {\\n    const img = document.createElement(\'img\')\\n    //设置回调\\n    img.onload= () => { resolve(img) }\\n    img.onerror= () => { reject(new Error(\'图片加载失败 \'+ src)) }\\n    // 赋值，开始加载~\\n    img.src = src\\n  })\\n}\\n// 串行化的代码\\nloadImage(url1).then( img => {\\n  console.log(img.width)\\n  return img\\n}).then(img => {\\n  console.log(img.height)\\n  return loadImage(url2)\\n}).then(img => {\\n  console.log(img.width)\\n  return img\\n}).then(img => {\\n  console.log(img.height)\\n}).catch(es => {console.error(es)})\\n```\\n\\n#### 关于then和catch的面试题\\n\\n```javascript\\nPromise.resolve().then(() =>{\\n  console.log(1)\\n}).catch(() =>{\\n  console.log(2)\\n}).then(() =>{\\n  console.log(3)\\n}) // 1 3\\n\\nPromise.resolve().then(() =>{\\n  console.log(1)\\n  throw new Error(\'error1\')\\n}).catch(() =>{\\n  console.log(2)\\n}).then(() =>{\\n  console.log(3)\\n}) // 1 2 3\\n\\nPromise.resolve().then(() =>{\\n  console.log(1)\\n  throw new Error(\'error1\')\\n}).catch(() =>{ //返回fulfilled\\n  console.log(2)\\n}).catch(() =>{\\n  console.log(3)\\n}) //1 2\\n```\\n\\n#### 来康康有关于async和await执行顺序\\n\\n1.\\n\\n```JavaScript\\nasync function func1() {\\n  console.log(2)\\n  await func2()\\n  // 以下相当于异步回调callback\\n  console.log(5) //异步的第一步\\n  await func3()\\n  // 以下又一层异步回调嵌套\\n  console.log(7)\\n}\\nasync function func2() {\\n  console.log(3)\\n}\\nasync function func3() {\\n  console.log(6)  //第一层异步结束\\n}\\n\\nconsole.log(1)\\nfunc1()\\nconsole.log(4) // 同步代码执行完成，event loop开始\\n```\\n\\n2.\\n\\n```JavaScript\\nasync function async1() {\\n  console.log(2);\\n  await async2();  // await以下异步, 微任务1，await相当于then\\n  console.log(5);\\n}\\n\\nasync function async2() {\\n  console.log(3);\\n}\\n\\nconsole.log(1);\\n\\nsetTimeout(()=>{  // 宏任务\\n  console.log(7);\\n},0)\\n\\nasync1();\\n\\nnew Promise((resolve)=>{ // 微任务2， 但是promise里面的函数立即执行\\n  console.log(4);\\n  resolve();\\n}).then(()=>{\\n  console.log(6);\\n});\\n// 同步任务\\n// 微任务\\n// dom渲染\\n// event loop 宏任务\\n```\\n\\n\\n\\n## 模块化\\n\\n# JS-Web-API\\n\\n## DOM\\n\\n### 本质\\n\\n从html解析出来的一棵树\\n\\n### DOM节点操作\\n\\n+ 获取：id， tagname， classname， queryselectorall\\n+ property：通过对dom元素js变量的属性的修改，不体现在thml的结构中\\n  .style.width, .calssName, .nodeName, .nodeType\\n+ setAttribute, getAttribute, 修改html属性，会体现到html中\\n+ 两者都可能引起DOM重新渲染\\n\\n### DOM结构操作\\n\\n+ 新增插入\\n  1. createElement， innerHTML\\n  2. appendChild\\n+ 移动节点：appendChild现有节点就是移动节点\\n+ 获取父元素 .parentNode 子元素列表.childNodes\\n\\n### DOM性能\\n\\n+ 做缓存，比如不在for头里写dom操作\\n+ 做打包，.createDocumentFragment, 创建临时区域，频繁操作都在临时区域里面插入，最后把区域一次性插入dom\\n\\n\\n\\n## BOM\\n\\n### navigator和screen\\n\\n+ navigator.userAgent (ua) ：浏览器信息\\n+ screen：.width .height \\n\\n### location\\n\\n+ .protocol：https、http\\n+ .host：www.baidu.com\\n+ .search：查询的参数\\n+ .hash: #abc\\n+ .pathname: /xx/xxx\\n\\n### history\\n\\n+ .back .forward\\n\\n\\n\\n## 事件绑定\\n\\n### 通用的事件绑定函数\\n\\n```JavaScript\\nfunction bindEvent (elem, type, fn) {\\n  elem.addEventListener(type, fn)\\n}\\n\\nconst btn = document.getElementById(\'btn\')\\nbindEvent(btn, \'click\', elem => {\\n  console.log(event.target) //谁触发的\\n  event.preventDefault()  //阻止默认行为\\n  alert(\'click\')\\n})\\n```\\n\\n### 事件冒泡\\n\\n事件在目标元素上触发后，并不在这个元素上终止。它会随着DOM树一层层向上冒泡，回溯到根节点。\\n冒泡过程非常有用。它将我们从对特定元素的事件监听中释放出来，如果没有事件冒泡，我们需要监听很多不同的元素来确保捕获到想要的事件。\\n\\n```html\\n\\t<body>\\n\\t\\t<div id=\\"div1\\">\\n    \\t\\t<p id=\\"p1\\">激活</p>\\n    \\t\\t<p id=\\"p2\\">取消</p>\\n    \\t\\t<p id=\\"p3\\">取消</p>\\n    \\t\\t<p id=\\"p4\\">取消</p>\\n  \\t\\t</div>\\n  \\t\\t<div id=\\"div2\\">\\n    \\t\\t<p id=\\"p5\\">取消</p>\\n    \\t\\t<p id=\\"p6\\">取消</p>\\n  \\t\\t</div>\\n\\t</body>\\n```\\n\\n```JavaScript\\n // 事件冒泡\\n    const p1 = document.getElementById(\'p1\')\\n    const body = document.body\\n    bindEvent(p1,\'click\',e=>{\\n      e.stopPropagation();  // 阻止冒泡\\n      alert(\'激活\')\\n    })\\n    bindEvent(body,\'click\',e =>{\\n      alert(\'取消\')\\n    })\\n```\\n\\n### 事件代理\\n\\n“事件代理”即是把原本需要绑定在子元素的响应事件（click、keydown......）委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。\\n\\n+ e.target获取触发元素\\n+ .matches来判断是否符合选择器\\n\\n```html\\n// 要给每个li添加不同事件\\n<ul id=\\"list\\">\\n  <li>item 1</li>\\n  <li>item 2</li>\\n  <li>item 3</li>\\n  ......\\n  <li>item n</li>\\n</ul>\\n```\\n\\n```javascript\\nconst list = document.getElementById(\'list\')\\nlist.addEventListener(\'click\', e=>{\\n  const target = e.target\\n  if(e.nodeName === \'li\'){\\n    alert(target.innerHTML)\\n  }\\n})\\n```\\n\\n### 题目\\n\\n#### 实现一个通用事件监听函数？\\n\\n```javascript\\nfunction bindEvent (elem, type, selector, fn) {\\n  if (fn == null) {\\n    fn = selector\\n    selector = null\\n  }\\n  elem.addEventListener(type, event => {\\n    const target = event.target\\n    if(selector){ // 代理\\n      if(target.matches(selector)) {\\n        fn.call(target, event)\\n      }\\n    } else { // 普通绑定\\n        fn.call(target, event)\\n    }\\n  })\\n}\\n```\\n\\n#### 事件冒泡的流程？\\n\\n#### 无线下拉的图片列表，如何监听每个图片的点击？\\n\\n\\n\\n## ajax\\n\\n### XMLHttpRequest\\n\\najax的核心就是XMLHttpRequest\\n\\n```javascript\\nconst xhr = new XMLHttpRequest()\\nxhr.open(\'GET\',\'/data/ajax.json\', true) \\n// true代表异步，这里是先打开，没有动作\\nxhr.onreadystatechange = function() {\\n  if (xhr.readyState === 4) {\\n    if(xhr.status === 200){\\n      console.log(JSON.parse(xhr.responseText))\\n    }\\n  }\\n}\\nxhr.send(null) // readyState改变，触发回调\\n```\\n\\n### 状态码\\n\\n#### xhr.readyState\\n\\n+ 0 还没有初始化，就是没调用send方法\\n+ 1 载入 已经调用send 正在发送\\n+ 2 send完成，已经接受到相应内容\\n+ 3 正在解析响应\\n+ 4 相应内容解析完成，可以再客户端调用\\n\\n#### xhr.status\\n\\n+ 2xx - 成功处理请求 200\\n+ 3xx - 需要重定向 301 302 304\\n+ 4xx - 客户端请求错误 403 404\\n+ 5xx - 服务端错误\\n\\n### 跨域：同源策略，跨域解决方案\\n\\n+ ajax请求的时候，浏览器要求当前网页和server必须同源\\n+ 同源：协议，域名，端口三者保持一致\\n  eg: 前端 http://a.com:8080/ server: https://b.com/api/xxx 则不同源\\n+ 图片，css，js可以无视同源策略\\n\\n#### JSONP\\n\\n+ `<script>`可绕过跨域限制\\n+ 服务器可以任意动态拼接数据返回\\n+ 所以script就可以在服务器允许的情况下跨域\\n\\n#### CORS\\n\\n后端做的\\n\\n### 题目\\n\\n#### 手写简易ajax？\\n\\n```javascript\\nfunction ajax(url) {\\n  let p = new Promise((resolve, reject) => {\\n    const xhr = new XMLHttpRequest()\\n    xhr.open(\'GET\',url, true) // 异步\\n    xhr.onreadystatechange = function () {\\n      if (xhr.readyState === 4){\\n        if(xhr.status === 200){\\n          resolve(JSON.parse(xhr.responseText))\\n        } else if (xhr.status === 404) {\\n          reject(new Error(\'404 not found\'))\\n        }\\n      }\\n    }\\n    xhr.send(null)\\n  })\\n  return p\\n}\\n\\nlet data = ajax(\'/data/ajax.json\')\\n.then(res=>console.log(res))\\n.catch(err=>console.error(err))\\n```\\n\\n\\n\\n## 存储\\n\\n### cookie\\n\\n+ 本身用于浏览器和server通讯\\n+ 被借用到本地存储\\n+ 可以用document.cookie = \' \' 修改，分号分割，每个都是key=value的形式，这个api不会覆盖，新的key会追加，已经有的会更新\\n+ 存储最大4kb\\n+ 请求的时候会发送到服务端，增加了数据请求量\\n\\n### localStorage和sessionStorage\\n\\n+ 为html5设计，最大5m\\n+ setItem，getItem\\n+ 不会随着http发动请求\\n+ local数据会永久存储，session只存在于当前会话， 关闭了浏览器就会清空了\\n\\n# HTTP协议\\n\\n## 状态码\\n\\n| 1**  | 信息，服务器收到请求，需要请求者继续执行操作   |\\n| ---- | ---------------------------------------------- |\\n| 2**  | 成功，操作被成功接收并处理                     |\\n| 3**  | 重定向，需要进一步的操作以完成请求             |\\n| 4**  | 客户端错误，请求包含语法错误或无法完成请求     |\\n| 5**  | 服务器错误，服务器在处理请求的过程中发生了错误 |\\n\\n常用：\\n\\n+ 200 成功\\n+ 301 永久重定向，配合location，浏览器自动处理\\n+ 302 临时重定向 eg：百度\\n+ 304 资源未被修改，你请求过啦，资源在本地还有效\\n+ 404 资源未找到\\n+ 403 没有权限\\n+ 500 服务器错误\\n+ 504 网关超时\\n\\n## http methods\\n\\n### 传统的\\n\\n+ get获取服务器数据\\n+ post向服务器提交数据\\n\\n### 现在的\\n\\n+ get 获取数据\\n+ post新建数据\\n+ patch/put 更新数据\\n+ delete 删除数据\\n\\n### restful API\\n\\n+ 传统API：\\n  + 每个url当做一个功能\\n  + 使用url参数：api/list?pageIndex=2\\n  + 操作类型都写在url\\n    post   /api/update-blog?id=100\\n+ RestfulAPI：\\n  + 每个url当做一个唯一资源\\n  + 不使用url参数：api/list/2\\n  + 用method表示操作类型\\n    post /api/blog\\n    patch  /api/blog/100\\n\\n## http Headers\\n\\n###  request headers\\n\\n+ accept 浏览器可以接受的数据格式\\n+ accept-encoding 浏览器可接受的压缩算法比如gzip\\n+ Connection：keep-alive 一个TCP重复使用\\n+ cookie\\n+ host\\n+ User-Agent：简称UA，浏览器信息\\n+ Content-type 发送数据的格式，比如application/json\\n\\n### Response Headers\\n\\n+ content-type 数据类型\\n+ content-length 返回数据大小，字节\\n+ content-encoding 返回数据的压缩算法\\n+ set-cookie 改动cookie\\n\\n## http缓存 \\n\\n![image-20210326141410099](https://ebcode.oss-cn-shanghai.aliyuncs.com/img/image-20210326141410099.png)\\n\\n浏览器缓存主要有两类：缓存协商和彻底缓存，也有称之为协商缓存和强缓存。\\n\\n1.强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的network选项中可以看到该请求返回200的状态码;\\n\\n2.协商缓存：在第一次请求服务器时，服务器会返回资源，并且返回一个资源的缓存标识，一起存到浏览器的缓存数据库。\\n当第二次请求资源时，浏览器会首先将缓存标识发送给服务器，服务器拿到标识后判断标识是否匹配，如果不匹配，表示资源有更新，服务器会将新数据和新的缓存标识一起返回到浏览器；如果缓存标识匹配，表示资源没有更新，并且返回 **`304`** 状态码，浏览器就读取本地缓存服务器中的数据。\\n\\n### 缓存中的header参数\\n\\n#### 强制缓存\\n\\n**Cache-Control：**当值设为max-age=秒，则代表在这个请求正确返回时间内再次加载资源，就会命中强缓存。设置值：\\n**private**：客户端可以缓存\\n**public**：客户端和代理服务器均可缓存；\\n**max-age=xxx**：缓存的资源将在 xxx 秒后过期；\\n**no-cache**：需要使用协商缓存来验证是否过期；\\n**no-store**：不可缓存\\n\\n#### 协商缓存\\n\\n **Last-Modified**：第一次请求资源时服务器通过 `Last-Modified` 来设置响应头的缓存标识，并且把资源最后修改的时间作为值填入，然后将资源返回给浏览器。\\n**If-Modified-Since**：在第二次请求时，浏览器会首先带上 `If-Modified-Since` 请求头去访问服务器，后者进行匹配，一致返回304，不一致则返回新的资源，并且更新Last-Modified\\n**Etag**：`Etag` 的值由服务端生成。在第一次请求时，服务器会将资源和 `Etag` 一并返回给浏览器，浏览器将两者缓存到本地缓存数据库。\\n**If-None-Match**：原理同`If-Modified-Since`\\n\\n### 刷新操作\\n\\n+ 正常操作：强制缓存，协商缓存都有效\\n+ 手动刷新：强制缓存失效，协商缓存有效\\n+ 强制刷新：都失败"},{"id":"0003","date":"2021-3-15","category":"前端","tag":["CSS"],"top":true,"title":"CSS学习笔记-bilibili-pink老师","description":"这是CSS比较全面的属性，布局，实战，辅助工具(PS切图等等)学习记录，是根pink老师学习CSS码的，老师的讲课思路非常棒，因此笔记内容也就很好用。","cover":"http://www.tastones.com/img/Tutorial/CSS/css-illustration.png","content":"# 字体\\n\\n## font\\n\\nfont: font-style font-weight font-size/font-hight font-family\\n\\n+ 顺序不能颠倒\\n+ 必须保留font-size font-family  eg: font 20px \'yahei\'\\n\\n# 文本\\n\\n文本外观，颜色，对其，缩进，间距等等\\n\\n## 对齐 text-align\\n\\n只能设置水平对齐，是在盒子内对齐。\\n\\n## 装饰文本 text-decoration\\n\\n## 文本缩进 text-indent\\n\\ntext-indent  2em\\n\\n## 行高 line-height\\n\\n![image-20210306083614739](https://ebcode.oss-cn-shanghai.aliyuncs.com/img/image-20210306083614739.png)\\n\\n从第一行的最下沿到第二行的最下沿就是行高\\n\\nline-height 等于盒子的高度，居中，大于盒子高度，偏下，小于盒子的高度，偏上\\n\\n# Emment语法\\n\\n+ 批量 div*10 + tab\\n+ 包含> div>span + tab\\n+ 兄弟 + \\n+ .classname + tab 默认div  p.classname 就是<p class=\'classname\'> </p>\\n+ 自增符号$  eg: .classname$*5 就是自增排序了\\n+  {}可以添加内容 比如 div{pig}*5 就是五个内涵pig的div  \\n+ 混合${} eg: div{$}*5\\n+ css 可以w100 + tab = width: 100px;\\n\\n \\n\\n# 复合选择器\\n\\n## 后代选择器\\n\\n 父 子 孙 ... {\\n\\n}\\neg: .nav li a { color:  red;}\\n\\n## 子选择器\\n\\n最近一级子元素，亲儿子，孙子都不行\\n父 > 子 {\\n\\n }\\n\\n## 并集选择器\\n\\na, b, c, ... {\\n\\n}\\n\\neg:  1. 喜欢竖写 2.最后一组不需要逗号 \\ndiv, \\np , \\n.pig li {\\n\\n}\\n\\n# 伪类选择器\\n\\n## 链接\\n\\n+ a:link 未访问过的链接\\n+ a:visited 访问过的\\n+ a:hover 鼠标悬停\\n+ a:active 鼠标正在按下还没有抬起来的   \\n+ 需要按照lvha的顺序来定义才有效果\\n\\n## :focus\\n\\n选取获得焦点的表单\\n\\ninput:focus {\\n}\\n\\n# 元素显示模式\\n\\n## 块元素\\n\\n+ 可以指定高度宽度\\n+ 没有置顶宽度就和父亲一样宽\\n+ 文字块级元素，h,p里面不能再放div了，会出问题\\n\\n## 行内元素\\n\\n+ 宽和高设置无效\\n+ 只能放文本和行内，放块元素要出错\\n\\n## 行内块元素\\n\\n+ input img td\\n+ 在一行上，但是之间有空白缝隙\\n+ 默认宽度就是本身内容宽度\\n+ 宽度高度，内外边距都可以控制\\n\\n## 行内 块 互相转化\\n\\ndisplay: block | inline | inline-block;\\n\\n# snipaste\\n\\n前端神器，我太爱了，可以截图，挂桌面，量px，取颜色\\n\\n# CSS背景\\n\\n## background-color\\n\\n## background-image\\n\\n+ <u>**装饰性图片** **logo 超大图片用背景图片**</u>\\n  background-image: url( );\\n\\n+ background-repeat 背景平铺，默认平铺，可以选择no-repeat\\n\\n+ 背景颜色和背景图片可以混用，图片在上层\\n\\n## **background-positon** \\n\\n后面可以根方位名词和精确单位\\n\\n  1. 如果是方位名词，background-position *center top，两个值前后无关，顺序可以颠倒*\\n     *省略一个，默认居中*\\n  2. 如果是精确单位，第一个x，第二个y\\n     *如果省略一个，默认给定的是x，剩下的一个居中*\\n  3. 可以混合方位名词和精确单位, 第一个x，第二个y\\n     *background-position: 20px center;*\\n\\n4. 超大背景图片用这个可以保证居中，直接给body一个bp属性，而且屏幕越大，看到的越多，但是中心核心内容都可以保证\\n   `body {\\n      background-image: url(...);\\n      background-position: center top;\\n   }`\\n\\n## 背景固定 background-attachment\\n\\n可以 **视差滚动** qq官网\\n\\nbackground-attachment: scroll | fixed;\\n\\n## 复合写法 background\\n\\nbackground: 颜色 图片地址 平铺 滚动 位置\\n这个是约定俗成的顺序 \\n\\n## 背景半透明\\n\\nbackground: rgba(0, 0, 0, .5);\\n\\n\\n\\n# css 三大特性\\n\\n## 层叠性\\n\\n就是覆盖冲突的样式，样式冲突，就近原则。\\n\\n## 继承性\\n\\n+ 比如继承body的字体，颜色\\n+ text- font- line- color 这些可以继承，高度，内外边距不可以继承\\n+ 行高的继承，如果父亲设置行高1.5 那子元素的行高就是子元素字体大小的1.5倍\\n  body{ font: 12px/1.5 \'YaHei\'} 就是子元素行高是字体的1.5\\n\\n## 优先级\\n\\n继承/*0000\\t元素0001 \\t类/伪类 0010\\tID0100 \\tstyle=\\"\\" 1000\\t!important  inf\\n继承的权重是0， 不管他爸选择器权重多高，所以继承的干不过浏览器默认样式\\n\\n### 权重叠加\\n\\nul li {} 的权重 0, 0, 0, 1+ 0, 0, 0, 1\\n.nav li {} 0, 0, 1, 0 + 0, 0, 0, 1 \\na:hover 11\\n**叠加不会进位**\\n\\n# 盒子模型\\n\\n## 盒子模型\\n\\nmargin border padding content\\n\\n### border\\n\\n+ border: 1px solid red; 没有固定顺序\\n  border-top: 2px solid red;\\n  border-collapse: collapse; 合并相邻边框，应用场景：表格\\n  **border会增加盒子的实际大小，需要减去**\\n\\n### padding\\n\\n+ padding v1\\n  padding v1 v2\\n  padding v1 v2 v3 左右v2，上1下3\\n  **padding 也会影响盒子的实际大小，要计算好content的width和height，防止吧其他盒子送走** \\n+ **tips** 可以利用padding撑开盒子，设置导航栏按钮，解决按钮内字数不同的问题，这样每个按钮之间距离看起来就是相等的\\n  ![image-20210308140736111](https://ebcode.oss-cn-shanghai.aliyuncs.com/img/image-20210308140736111.png)\\n+ 在没指定width/height的时候padding不会撑开盒子大小，就是没设置宽度，继承了爸爸的宽度，然后padding就会往里面挤，如果设置了宽度，那padding就会往外扩张\\n  （问：那那个a是咋回事呢? 猜测可能是inline-block）\\n\\n### margin\\n\\n+ computed可以看到参数\\n+ 盒子水平居中 margin: 0 auto;\\n  对于行内/行内块元素，则需要在他的父亲text-align: center\\n+ 父盒子里面套子盒子，当子盒子设置了垂直margin，父盒子就会**塌陷**。\\n  + 只要父亲有边框就不会塌陷\\n  + 父亲来个内边距\\n  + overflow: hidden;\\n+ 清除内外边距` * {margin:0; padding:0}`\\n+ 行内元素很大情况下上下外边距不起作用\\n\\n## 圆角边框\\n\\nborder-radius: 圆的半径 |  百分比; \\n\\n+ 圆形：先准备一个正方形 border-radius: 50%;\\n+ 胶囊：高度的一半\\n\\n## 盒子阴影\\n\\nbox-shadow: h-shadow v-shadow blur spread color inset;\\n\\n+ h-shadow影子的左右\\n+ blur 虚实\\n+ spread 大小\\n+ 默认外阴影 可选inset\\n\\n## 文字阴影\\n\\n同上 但是只有前四个值\\n\\n\\n\\n# 浮动\\n\\nCSS的三种传统布局方式是 标准流，浮动，定位，网页会由三种方式一起布局\\n**网页布局第一准则：多个块级纵向排列找标准流，横向排列找浮动**\\n\\n**第二准则：先设置盒子大小，再设置盒子位置**\\n\\n## 浮动特性\\n\\n+ 1. 脱离标准流的控制，移动到指定位置，称作**脱标**\\n  2. 萝卜不再保留原先的坑\\n+ 如果多个盒子都浮动，会按照**一行内顶端对齐显示**，中间没有空隙\\n+ **任何元素如果浮动会给予行内块元素的特性**，比如，块级盒如果没有设置宽度，默认和爸爸一样宽，但是浮动后，就由内容决定\\n\\n## 浮动搭配标准流父亲盒子\\n\\n一般，先用标准流父亲上下排列，然后在盒子内采用浮动排列左右位置。\\n\\n## 浮动注意点\\n\\n浮动的盒子只会影响盒子后面的标准流，不会影响前面的标准流。 \\n\\n\\n\\n## 清除浮动\\n\\n在父盒子没指定高度的时候，子盒子设置了浮动，那么父盒子高度会变成0\\n清除浮动就是清除浮动造成的影响，爸爸可以根据孩子自动撑开高度,清除浮动的策略就是**闭合浮动**, 只让浮动在父盒子里面有影响.\\nclear: both;\\n\\n1. **额外标签法**：最后一个孩子添加一个class, 然后css中选择并且添加 clear: both;\\n   这个最后的盒子必须是块级元素\\n\\n2. **父亲添加overflow**\\n\\n3. **after伪元素**\\n   在css添加如下代码\\n\\n   ```css\\n   .clearfix:after {\\n   \\tcontent: \\"\\";\\n   \\tdisplay: block;\\n   \\theight: 0;\\n   \\tclear: both;\\n   \\tvisibility: hidden;\\n   }\\n   \\n   .clearfix {\\n   \\t/* IE6、7 专有 */\\n   \\t*zoom: 1;\\n   }\\n   ```\\n\\n   然后在父元素上添加clearfix类\\n\\n4. **双伪元素**(推荐)\\n\\n   ```css\\n   .clearfix:before,.clearfix:after {\\n   \\tcontent: \\"\\";\\n   \\tdisplay: table;\\n   }\\n   \\n   .clearfix:after {\\n   \\tclear: both;\\n   }\\n   \\n   .clearfix {\\n   \\t*zoom: 1;\\n   }\\n   ```\\n\\n\\n\\n# PS切图\\n\\n## 图层切图\\n\\n右键图层, 导出为png\\n很多时候需要合并图层在导出, 先选中, 然后合并,然后在导出\\n\\n## 切片切图\\n\\n先切片, 文件, 导出, web格式, 选格式, 存储, 选中的切片, 保存\\n如果想要透明, 就把背景隐藏掉\\n切片选择工具可以移动切片位置, 选中切片按delete删除切片\\n\\n## cutterman切图\\n\\n官网下载安装, 窗口  扩展功能  cutterman\\n直接选中,导出选中图层\\n如果是多个图层, 那就合并导出选中图层 \\n\\n\\n\\n# 学成在线案例\\n\\n## CSS属性书写顺序(重要 )\\n\\n![image-20210309103409382](https://ebcode.oss-cn-shanghai.aliyuncs.com/img/image-20210309103409382.png)\\n\\n## 布局思路\\n\\n1. 确定版心, 确定宽度\\n2. 确定行模块, 用标准流\\n3. 确定列模块, 用浮动\\n4. 先写结构, 再写样式\\n\\n## 导航栏思路\\n\\n实际开发中,不会直接用链接a而**用li 包含at的做法**, 这是个professional的做法\\n如果直接用a, 搜索引擎会觉得有关键字堆砌,降低网页权重\\n\\n\\n\\n# 定位\\n\\n可以让盒子在盒子中自由飞翔, 或者固定在屏幕的某个位置的时候用定位\\n**定位 = 定位模式 + 边偏移**\\n\\n## static\\n\\n默认, 没有定位, 没有边偏移\\n\\n## relative\\n\\n1. 相对于原来位置的定位进行边偏移\\n2. **不脱标**萝卜原来的坑会被保留, 因此很大程度上的用途是给绝对定位当爸爸\\n\\n## ablolute\\n\\n相对于祖先元素的绝对定位\\n\\n1. 如果没爸爸, or爸爸没有定位, 那document就是爸爸\\n2. 祖先元素有定位(只要不是static), 那就是对于祖先的绝对定位, 祖先是爸爸, 爷爷, 都行, 最近的一个. \\n3. 脱标, 萝卜坑不再保留\\n\\n## fixed\\n\\n以浏览器可视窗口为参照固定定位\\n\\n1. 和父亲没有关系, 也不随着滚动条滚动\\n2. 脱标, 不留坑\\n\\n## sticky\\n\\n大部分的效果都是js, 而不是这个, 这个兼容性不好\\n\\n1. 浏览器窗口为参照物\\n2. 不脱标, 留坑\\n3. 必须添加top left right bottom其中的一个\\n\\n## 子绝父相\\n\\n当子采用绝对定位的时候, 需要父亲也拥有定位, 对于父亲来说, 拥有定位之后还要保留原来的位置, 于是父亲应当拥有相对定位.\\n\\n## fixed贴版心算法\\n\\nleft: 50%;\\nmargin-left: 版心的一半;\\n\\n## 定位次序 z-index\\n\\n默认auto, 越大越靠上, 但是不能加单位\\n只有定位的盒子才有此参数\\n\\n## 绝对定位居中\\n\\nleft: 50%;\\nmargin-left: -盒子宽度的一半;\\n\\ntop: 50%;\\nmargin-top: -高度的一半;\\n\\n## 定位特性\\n\\n1. 如果添加了absolute或者fixed, 就可以直接设置宽度无需转block\\n2. 如果块元素加了定位, 还没给宽度高度, 那就是内容的宽高\\n3. 脱标的盒子不会引起margin塌陷\\n4. float不会压住标准流的文字, positon连文字都一起压住\\n\\n\\n\\n# 精灵图\\n\\n减少服务器请求次数, 加快页面加载速度.\\n\\n+ 针对于背景图片\\n\\n+ CSS二倍精灵图使用方法https://blog.csdn.net/weixin_39295546/article/details/104709129\\n\\n+ 二倍精灵图,所以用ps缩放一半\\n\\n  ![image-20210311151040935](https://ebcode.oss-cn-shanghai.aliyuncs.com/img/image-20210311151040935.png)\\n\\n  ![image-20210311151130063](https://ebcode.oss-cn-shanghai.aliyuncs.com/img/image-20210311151130063.png)\\n\\n  窗口 -> 信息 就可以看到当前鼠标坐标\\n\\n  ![image-20210311151223940](https://ebcode.oss-cn-shanghai.aliyuncs.com/img/image-20210311151223940.png)\\n\\n  然后写代码\\n\\n\\n\\n# CSS3\\n\\n## 属性选择器\\n\\n+ E[att]\\n+ **E[att=val]**\\n+ E[att^=val] 属性att以val开头的元素\\n+ E[att$=val] .....结尾.....\\n+ E[att*=val] ......含有....\\n+ 属性选择器权重10\\n\\n## 结构伪类选择器\\n\\n+ E:first-child\\tE:last-child 是第一个孩子的E元素\\n\\n+ E:nth-child(n) 是第n个孩子的E元素\\n   n可以是 even, odd\\n  也可以是n, 只能是字母n, 就是选择了所有孩子\\n  2n: 2x0 2x1 2x2 2x3 即偶数孩子\\n  5n: 5的倍数\\n  n+5: 从第五个到最后\\n-n+5: 前5个\\n  \\n+ E:first-of-type\\n\\n  ```css\\n  div:nth-child(1) {\\n  \\t/*先找指定序号, 再去看是不是指定元素*/\\n  }\\n  div:nth-of-type(1) {\\n  \\t/*先找指定元素, 再去找序号*/\\n  }\\n  ```\\n\\n  \\n\\n## 伪元素选择器\\n\\n通过CSS插入元素, 避免html标签嵌套, 叫伪元素是因为在文档树中找不到这个元素\\n\\n### element::before | element::after\\n\\n+ 在element里面的内容的前面/后面加上盒子\\n+ 必须有content元素\\n+ 是行内元素\\n+ 权重是1\\n\\n\\n\\n## 渐变颜色\\n\\nbackground: -webkit-linear-gradient(left, red, blue)\\n必须添加私有前缀\\n\\n\\n"},{"id":"0004","date":"2021-3-15","category":"前端","tag":["CSS","移动端布局"],"top":true,"title":"移动端CSS学习笔记","description":"学习移动端布局太重要了，值得分出来写个笔记，pink老师出了挺多移动端布局的教程，很系统也很精致，整理了精华部分。","cover":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fmycloudb.com%2FAttach%2Fimage%2F20200606%2F20200606165117_94850.png&refer=http%3A%2F%2Fmycloudb.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1618367710&t=dce06c6f680437ec7e720e0c391feca4","content":"# 基础\\n\\n## meta视口标签\\n\\n```html\\n<meta name=\\"viewport\\" content=\\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\\">\\n```\\n\\n取消默认的980px视口, 来用理想视口显示\\n\\n## 物理像素比\\n\\n在pc上1px等于屏幕上的一个像素点\\n在移动端, 就不一定, 一个px能显示的物理像素点的个数, 称之为物理像素比or屏幕像素比\\neg: iPhone678 都是2\\n物理像素是750, 1px等于两个物理像素\\n\\n## 二倍图\\n\\n为了解决在**Retina屏幕**放大了图像倍数导致**模糊**的问题, 采用了倍图提高图像质量, 两倍于开发尺寸的图像大小, 压缩成正常大小\\n\\n## 二倍精灵图\\n\\nCSS使用二倍精灵图的方法https://blog.csdn.net/weixin_39295546/article/details/104709129\\n\\n## background-size\\n\\n+ 拉伸背景图, 只给一个参数就是宽度,\\n+ 也可以给百分比, 更方便\\n+ 值 cover是完全盖住盒子\\n+ contain 宽度到了就行\\n\\n## 移动端开发选择\\n\\n+ 单独开发移动端页面\\n+ 响应式兼容pc移动端 \\n\\n## 移动端初始化CSS\\n\\nnomalize.css\\n\\n## box-sizing\\n\\nbox-sizing: border-box;\\n有了这句就让盒子变成CSS3盒子模型, border和padding不会再撑开盒子了. \\n\\n## 流式布局\\n\\n+ 也就是百分比布局\\n+ max-width 最大宽度 min-width 最小宽度\\n\\n\\n\\n# flex布局\\n\\n## 原理\\n\\n+ float、clear、vertical-align属性失效\\n+ 又叫伸缩布局 弹性布局\\n+ 采用flex称作flex容器, 成员成为flex项目\\n+ 通过给父亲添加flex属性,控制子盒子的位置和排列方式\\n\\n## flex 父项的属性\\n\\n**父亲必须有display: flex**\\n\\n### flex-direction 主轴方向\\n\\nflex-direction: row | column;\\n\\n+ 设置谁谁就是主轴, 剩下的就是侧轴喽\\n+ 元素按照主轴排列\\n\\n### justify-content 主轴子元素对齐方式 \\n\\n+ 一定要先确认好主轴\\n+ flex-start 左到右 默认\\n+ center 居中对齐\\n+ space-around 平分剩余空间\\n+ space-between 两边贴边, 剩余平分\\n\\n### flex-wrap 换行\\n\\nflex默认不换行，如果装不开，缩小子元素宽度，硬塞进去\\nflex-wrap: warp  就可以另起一行显示\\n\\n### align-items 侧轴上的对齐方式（单行）\\n\\n侧轴是相对于主轴的，默认的主轴是x\\nalign-items: xxx\\n\\n+ flex-start | center | stretch(子元素不能设置高度，就会沿着y轴去拉伸)\\n+ 对齐方式先主轴，然后侧轴, 所以 主轴是x, 还是y, 都居中, 结果不一样\\n+ 只适用于单行子元素的情况\\n\\n### align-content 侧轴对齐方式（换行时）\\n\\n出现多行时候才有效\\n\\n+ flex-wrap: wrap; 因为有了换行，所以用align-content\\n+ align-content:  flex-start | center | space-between | space-around...\\n\\n### flex-flow 符合属性\\n\\nflex-flow: row wrap;\\n行主轴，而且换行\\n\\n## 子项属性\\n\\nflex的子项行内元素产生宽度高度\\n\\n### flex 剩余空间分几份\\n\\n排除了已经给的width/height, 剩余的距离平均分\\nflex 1 | 2 |3 ..... 也可以是百分比\\n注意, 这个的计算方式是, 一个父亲下有三个儿子flex分别是 1, 2, 3, 那就是分别占1/6, 2/6, 3/6\\n\\n ### 在侧轴上的单独行动\\n\\nalign-self 控制子项在侧轴上的排列方式\\nalign-self: flex-end;\\n\\n### 排列顺序\\n\\norder: <number>; 越小越靠前，默认是0\\n\\n\\n\\n# Less\\n\\n## 变量\\n\\n@name: v;\\teg: @fontColor: #333;\\n\\n## 编译\\n\\neasy less插件, 会自动编译css, 引用就好了\\n\\n## 嵌套\\n\\n```less\\n.header {\\n  a {\\n    // 子元素直接卸载父元素里面\\n    &:hover {\\n      // 伪类, 伪元素, 交集选择器, 需要加&\\n    }\\n  }\\n}\\n```\\n\\n## 运算\\n\\n+ 运算符之间, 左右空格隔开\\n+ 第二个数字可以省略单位\\n+  两个数字单位不同,结果以第一个数的单位为准\\n+ 除法需要加括号\\n\\n## @import\\n\\n可以吧一个less导入less, link是导入到html\\n\\n\\n\\n# rem布局\\n\\n## 基础\\n\\nem是相对于父元素的字体大小来说的, rem是相对于html元素的字体大小来说的, 所以整体用rem布局, 当页面大小改变的时候, 只需要改变html元素的字体大小, 就可以实现改变页面元素大小整体控制\\n\\n## 媒体查询\\n\\n@media可以根据不同的屏幕尺寸设置不同样式\\n\\n```css\\n@media screen and (max-width:800px){\\n  /* 在小于等于800px的屏幕上 */\\n}\\n@media screen and (max-width:600px){\\n  /* 在小于等于600px的屏幕上 */\\n}\\n@media screen and (min-width:600px) and (max-width:700px) {\\n  /* 在600px-700px的屏幕上 */\\n}\\n```\\n\\n+ 一般按照从大到小or从小到大来设置\\n  从小到大更简洁, 因为可以层叠\\n\\n## 引入资源\\n\\n当样式比较多, 直接在link中判断设备尺寸, 准备多套css, 根据尺寸调不同的css\\neg: 当屏幕够大, 一行三个div, 当小屏幕, 一行1个div \\n\\n```css\\n<link rel=\\"stylesheet\\" href=\\"style320.css\\" media=\\"screen and (min-width: 320px)\\">\\n    <link rel=\\"stylesheet\\" href=\\"style640.css\\" media=\\"screen and (min-width: 640px)\\">\\n```\\n\\n## rem适配方案\\n\\n1. less + 媒体查询 + rem\\n2. flexible.js + rem\\n\\n\\n\\n# less+ 媒体查询 + rem\\n\\n## 元素大小\\n\\npink老师讲的太好: https://www.bilibili.com/video/BV14J4114768?p=453\\n\\n+ 将屏幕划分n等份, 作为html字体大小\\n+ 页面元素rem = 页面元素值px / (屏幕宽度/分的份数n)\\n+ or  元素rem = px / html.font-size\\n\\n来康康苏宁的写法\\n\\n![image-20210312103243050](https://ebcode.oss-cn-shanghai.aliyuncs.com/img/image-20210312103243050.png)\\n\\n苏宁分了15份\\n\\n***<u>所以, 就照着750px宽度, 分成15份去写, 也就是一份50px, 去算rem, 在其他尺寸会自适应!!!!</u>***\\n\\n- *重点是, 假设给的设计稿是750px, 要求切15等份, 那么一份就是50px, 设置less变量@baseFont: 50px; 量取设计稿的px之后, 比如说36px的按钮, 那就是 (36rem / @baseFont), 就会转化成rem 注意 #baseFont应该跟着设计稿计算出来在设置, 要和设计稿尺寸统一, 就可以算出rem, 之后无论什么尺寸, 都是按照比例缩放的.*\\n\\n详见苏宁项目\\n\\n# flexible.js\\n\\n+ 自动划分10等份, 不需要去写媒体查询啦, 要做的只是按照设计稿/10得到font-size, 然后去算rem\\n\\n+ 因为是按照整个屏幕划分的, 因此需要加max-width约束一下\\n\\n+ 限制750宽度\\n\\n  ```css\\n  @media screen and (min-width:750px) {\\n    html {\\n      font-size: 75px!important;\\n    }\\n  }\\n  ```\\n\\n  \\n\\n## CSSREM 插件\\n\\n自动转化rem, 神器, 记得设置htmlroot的font-size哦, 不然默认是16px\\n\\nwebstrom 里面的是px2rem, 首选项  px to rem 设置root fontsize\\n\\n\\n\\n\\n\\n# 响应式开发\\n\\n基于媒体查询, 有一组划分屏幕的档位\\n\\n![image-20210312195200106](https://ebcode.oss-cn-shanghai.aliyuncs.com/img/image-20210312195200106.png)\\n\\n## 布局容器\\n\\n不同屏幕下, 通过媒体查询改变布局容器的大小, 再改变里面的子元素排列方式, 从而实现在不同屏幕下, 看到的布局样式不同\\n\\n一般叫做container, 直接用@media设置\\n\\n"},{"id":"0005","date":"2021-3-27","category":"葱妹自救指南","tag":["macOS"],"top":false,"title":"更聪明的macOS dock","description":"来让dock更聪明的自动隐藏，并且消除唤出延迟！软件推荐！","cover":"https://ebcode.oss-cn-shanghai.aliyuncs.com/img/image-20210328020054985.png","content":"## 前言\\n\\nmac中dock的体验是非常舒适的, 当然全屏应用的切换做的也很好, 但是关于dock的自动隐藏我却一直不是很喜欢, 原因其一是如果勾选了此项, dock会始终隐藏, 除非用鼠标去怼才愿意出来; 第二是用鼠标怼它的时候延迟时间(前摇)太长, 给我不流畅的感觉. 本文推荐两个软件来解决问题.\\n\\n![image-20210328020054985](https://ebcode.oss-cn-shanghai.aliyuncs.com/img/image-20210328020054985.png)\\n\\n## 解决自动隐藏唤出延迟\\n\\n软件Dockey可以帮忙! https://dockey.publicspace.co/\\n\\n当delay设置none的时候, 烦人的卡顿感消失了, 现在可以秒唤出了\\n\\n![image-20210328020206293](https://ebcode.oss-cn-shanghai.aliyuncs.com/img/image-20210328020206293.png)\\n\\n## 让dock聪明的自动隐藏\\n\\n怎么说的,需要dock有种莫挨劳资的感觉, 窗口靠近他, 他就躲起来, IntelliDock来了!https://mightymac.app/intellidock/\\n\\n没窗口遮挡的时候![image-20210328020506623](https://ebcode.oss-cn-shanghai.aliyuncs.com/img/image-20210328020506623.png)\\n\\n窗口靠近的时候\\n![image-20210328020531586](https://ebcode.oss-cn-shanghai.aliyuncs.com/img/image-20210328020531586.png)\\n\\n## 两者配合起来\\n\\n自然就是1+1>2!"}]}')},f56b:function(n,t,e){"use strict";e("5101")},f8d3:function(n,t,e){}});
//# sourceMappingURL=app.df402010.js.map